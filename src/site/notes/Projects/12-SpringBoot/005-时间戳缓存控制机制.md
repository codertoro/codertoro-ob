---
{"type":"springboot","title":"005-时间戳缓存控制机制","tags":null,"author":"codertoro","establish":"2025-07-23","update":"2025/07/23 15:27","dg-publish":true,"permalink":"/Projects/12-SpringBoot/005-时间戳缓存控制机制/","dgPassFrontmatter":true,"created":"2025-07-23T15:27:42.701+08:00","updated":"2025-07-23T15:28:04.770+08:00"}
---

# 1. 时间戳缓存控制机制（自定义版）

## 1.1. 请求流程

- 客户端发送请求
    
    - 携带请求头：`X-Last-Request-Time`
    - 可选强制刷新：`X-Force-Refresh`
- 服务端处理逻辑
    
    - 解析 URI，提取模块级 & 接口级 Key
    - 读取 Redis 中该模块/接口的 lastUpdateTime
    - 如果 Redis 中无值（首次请求），写入当前时间戳
    - 对比时间戳：
        - 如果 `lastRequestTime >= lastUpdateTime`：
            - 返回 304 Not Modified
        - 否则：
            - 返回最新数据，客户端刷新缓存

## 1.2. Redis 结构设计

- Redis Key 命名规则
    
    - 接口级：`cache:update-timestamp:{接口路径}`
    - 模块级：`cache:update-timestamp:{模块前缀}`
- 值：时间戳（毫秒级 `System.currentTimeMillis()`）
    
- TTL：24小时（可调）
    

## 1.3. 时间戳写入逻辑（服务端）

- 针对 `POST / PUT / DELETE` 请求
    - 写入接口级时间戳
    - 写入模块级时间戳

## 1.4. 时间戳读取逻辑（服务端）

- 针对所有请求
    - 从请求头读取 `X-Last-Request-Time`
    - 获取 Redis 中的更新时间戳
    - 若无，则写入当前时间
    - 对比时间，命中则返回 304

## 1.5. 类比技术

- HTTP 缓存机制
    - 类似于 Last-Modified / If-Modified-Since / ETag
- CDN 缓存控制
    - 基于时间戳判断是否返回资源
- 乐观锁机制
    - 时间戳用于判断版本是否一致
- 前端状态管理缓存（如 SWR、Apollo）
    - 利用时间戳增量更新
- Redis 双写一致缓存策略
    - 写操作触发时间戳刷新

## 1.6. 可能扩展

- 支持接口粒度更细的缓存判断
- 支持 `ETag` 风格的内容签名版本控制
- 配合前端缓存库统一处理
- 后台接口增加手动刷新时间戳功能